---
title: 大话数据结构和算法读书笔记（1/3）- 绪论/算法/字符串/树
date: 2019-05-05 17:01:12
tags:
- 数据结构
- 算法
- 读书笔记
---

《大话数据结构》我大概花了两整天时间读完，并整理了如下笔记。
这本书对学习/复习数据结构和算法基础知识很有帮助，尤其是许久不接触相关内容，阅读此书（或者我的笔记）应当可以迅速让你进入数据结构和算法的语境，达到可以入门/查漏补缺/刷题的状态。

# 绪论
## 定义数据/数据结构

### 数据
数据是描述客观世界的符号 
1. 可以输入到计算机中 
2. 能被计算机程序处理

将现实世界的数据 通过编码手段转换为字符数据类型

**数据元素** 是组成数据的、有一定意义的基本单位。通常作为整体处理。也被称为**记录**。
**数据项** 数据元素由若干数据项构成，是数据不可分割的最小单位。
**数据对象** 性质相同的数据元素的集合，是数据的子集。具有相同数量和类型的数据项。 在实际应用中，处理的元素通常具有相同的性质，因此一般将数据对象简称为数据。

(上述概念的含义： **数据由数据元素构成，数据元素由数据项构成，性质相同的数据元素称为数据对象**，一般实际应用是以**数据对象**为对象，因此它可以简称为**数据**。)

### 结构
结构简单的理解就是**关系**。
是各个组成部分相互搭配和排列的方式，不同数据元素之间不是独立的而是存在一定的关系，这种关系称为结构。
**数据结构** 是相互之间存在一种或多种特定关系的数据元素的集合。

## 数据结构分类
按照视点的不同，分为*逻辑结构*和*物理结构*
### 逻辑结构
逻辑结构是针对具体问题的，在对问题理解的基础上选择一个适合的结构表示元素之间的逻辑关系。
- **集合结构**
类似数学中的集合
- **线性结构**
数据元素之间是一对一的关系
- **树形结构**
数据元素之间存在一对多的层次结构
- **图形结构**
数据元素之间存在多对多的层次结构
### 物理结构
即*存储结构*，指数据的逻辑结构在计算机中的存储形式。(主要针对内存而言，外部存储通常用文件结构来描述) 它分为分两种：
- **顺序存储**
把数据元素存放在地址连续的存储空间里，其数据的逻辑关系与物理关系是一致的。
- **链式存储** 
把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。 存储关系并不反映其逻辑关系。

## 抽象数据类型
**数据类型**：一组性质相同的值的集合及定义在此集合上的一些操作的总称。

数据类型是按照值的不同来划分的
类型用来说明值或者表达式的取值范围和所能进行的操作

C语言中按照取值的不同，数据类型可以分为两类 
*原子类型*： 不可以再分的基本类型 如整型、实型、字符型
*结构类型*： 由若干个类型组合而成，是可以再分解的

**抽象**是指抽取出事物具有的普遍性的本质。
- 抽出特征而忽略非本质的细节。
- 隐藏细节/概括/保留实现目标所必须的信息。

抽象数据类型 abstract data type 一个数学模型及定义在该模型上的一组操作。
抽象的意义在于数据类型的**数学抽象特征**。
抽象数据类型体现了程序设计中问题分解/抽象和信息隐藏的特性。

# 算法
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。
算法有5个特性
1. 输入 算法有0到多个输入
2. 输出 算法至少有一个或者多个输出
3. 有穷性 算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤都在可接受的时间内完成。
4. 确定性 算法的每一个步骤都有确定的含义，不会出现二义性。
5. 可行性 算法的每一步都必须是可行的，也就是说说每一步都可以通过执行有限次数完成。

## 算法设计的要求
算法不是唯一的，同一个问题可以有多种解决问题的算法，没有标准答案
### 正确性
至少具有输入输出和加工处理 无歧义 能正确反映问题的需求 能够得到正确的答案
正确性大概有以下几个层次，要求逐渐提高。
- 算法没有语法错误
- 对于合法的输入能够产生满足要求的输出结果
- 对于非法输入能够得出满足规格说明的结果
- 对于精心选择的，刁难的测试数据都有满足要求的输出结果
一般来说到达第三层算是一个正确的算法。
因此算法的正确性一般不能用程序来证明，而是数学方法证明的。
### 可读性
算法设计的另一个目的是便于阅读、理解和交流。
### 健壮性
对输入数据不合法的情况做合理的处理，而不是产生异常或者莫名其妙的情况
### 时间效率高&存储量低
算法设计追求的目标

## 算法效率的度量方法
事后统计 受条件影响较大
事前分析 
分析程序运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤
## 函数的渐近增长
给定函数f(n)和g(n)，如果存在一个整数N，使得对于所有n>N，f(n)总是比g(n)大，那么我们认为f(n)的增长渐近快于g(n)。
通常忽略加法常数，与最高项相乘的常数并不重要
通过少量数据无法准确判断
判断一个算法饿效率时，函数中的常数和其他次要项常常可以忽略，更应该关注主项(最高阶项)的阶数。
## 算法时间复杂度
进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况 并确定T(n)的数量级。
算法的时间复杂度，也就是算法的时间度量记作 T(n)=O(T(n))。它表示随着问题规模n的变大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。
这样用O()来体现算法时间复杂度的记法我们称为大O记法。
O(1)常数阶 执行时间与问题大小无关
O(n)线性阶 
O(n2)平方阶
O(logn)对数阶

分析算法的复杂度，关键是要分析循环结构的运行情况。
大O推导 难点在于对数列的一些相关运算，考察数学知识和能力
最坏时间复杂度 平均时间复杂度 

#线性表
线性表list：零个和多个数据元素的有限序列。
非空表中每一个元素都有一个确定的位置。
除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素。元素之间的关系是一对一的。
两种物理类型
顺序存储结构 数组
链式存储结构 链表
#栈与队列
栈 stack 是限定仅在表尾进行插入和删除操作的线性表。 把允许插入和删除的一端称为栈顶top，另一端称为栈底bottom。LIFO 后进先出结构
进栈/插入 push 出栈/删除 pop
顺序存储栈
下标为0的一端作为栈底比较好，因为首元素在这儿，变化比较小
链式存储栈
栈顶放在链表的头部
## 栈的应用-后缀表示法
数学表达式求值表示法 
平时我们使用的标准四则运算式为中缀表达式，即所有的运算符号都在两个数字的中间
计算机使用 后缀表示法 即逆波兰表示法 Reverse Polish Notation **RPN**
名字叫后缀的原因是因为所有的符号都要在运算数字的后面出现
不需要括号
后缀表达式的计算方法： 从左到右遍历，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈进行运算(计算顺序为由内向外)，结果进栈，一直到最终获得结果。
后缀表达式的转换：
平时我们使用的标准四则运算式为中缀表达式，即所有的运算符号都在两个数字的中间，我们的问题就是中缀向后缀的转换。
规则：
从左向右遍历中缀表示法的每个数字和符号
如果遇到操作数，直接将其输出
如果遇到操作符，则将其放入到栈中，遇到左括号时也将其放入栈中。
如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，括号只弹出并不输出。
若是其他符号，判断其与栈顶符号的优先级，优先级不高于栈顶符号，则栈顶元依次出栈并输出，并将当前符号进栈，直至得到最终表达式

##队列的定义
queue 只允许在一端进行插入操作，而在另一端进行删除操作的线性表。先进先出。

### 队列顺序存储
引入两个指针，front 队头 rear队尾元素的下一个位置。
front == rear 空队列。
随着front后移这样容易出现假溢出，所以要使用循环队列，头尾相接。
队列的长度(rear-front+queueSize)/ queueSize
此时front == rear除了是空外，也可能是满，解决的办法：
1.引入flag来判断
2. 保留一个元素控件，还剩下一个位置时认为队满。(rear+1)%queueSize == front

### 队列链式存储
队列的链式存储结构其实就是单链表，只不过只能尾进头出而已，简称链队列。
为方便将队列头指针指向链表的头结点(此处应该指的是带头链表)，尾指针指向终端结点，队列为空时front 和rear都指向头结点。
入队在链表尾部插入结点 出队将头结点的后继改为它后面的结点。

# 字符串
零个或多个字符组成的有限序列。
串与线性表很类似，不同指出在于串针对的是字符集，其中的元素都是字符。因此其基本操作与线性表有很大的差异，线性表更关注的是单个元素的操作，比如查找/插入/删除一个元素；串更多的是超着字串位置/得到指定位置子串/替换子串等操作。

子串的定位操作通常被称做串的**模式匹配**
## KMP 模式匹配算法
主串 siz n， index i
子串 size m， index j
朴素模式匹配，i和j不断的回溯，最坏时间复杂度O((n-m+1)*m)平均？？
这样浪费了很多无谓的的计算，kmp目的是尽量减少不必要的回溯
i 不回溯
j可能回溯

j的值取决于子串中 当前字符之前的 串的  前后缀的相似程度
子串各个位置j值变化定义一个next数组
根据经验 前后缀n个字符相等 数组对应位置的值为n+1
通过先计算next数组，每次j值回到next数组指定值的位置。

这样能较好的提高效率，尤其是部分匹配较多的情况下 O(n+m)

进一步优化上面的算法
当子串类似aaaab这种类型时，next数组为01234，但对于 后面的a来说，比如比b时不匹配(aaaaxxx)，回到第四个a不匹配，此时按照next数组回到3(没有意义，因为4 3 2 1都相等)也只是再回到2 回到1在到0，说明还有修正的空间(还不如直接回到0)。
引入nextval
改进KMP算法，计算出next的值的同时，如果a位字符与它next值指向的b字符相等，则该a位的nextval就指向b位的nextval值，如果不相等，则该a位 nextval值就是它自己a位的next的值。

1 2 3 4 5 6 7 8 9
a b a b a a a b a
0 1 1 2 3 4 2 2 3  next
0 1 0 1 0 4 2 1 0 nextval

# 树
## 树的定义
Tree 是n个结点的有限集。 n = 0时称为空树。
在任意非空树中：
1. 有且仅有一个特定的称为根root的结点
2. 当n>1 时 其余结点可以分为m 个互不相交的有限集 T1、T2、Tn，其中每一个集合本身又是一棵树，并且称为根的子树subTree。
树的定义使用了递归的思想，即 树的定义中包含树。
需要强调的点 1.根结点是唯一的 2.子树的个数没有限制，但是它们一定是不相交的，相交就不符合树的定义(成了图)。

### 结点分类
树的结点包含一个数据元素及若干指向其子树的分支。 结点拥有的子树称为结点的**度Degree**。度为0的结点称为**叶结点Leaf**或者终端结点。度不为0的结点称为非终端结点或者分支结点，除跟结点外分支结点也称为**内部结点**。 **树的度**是树内各结点的度的最大值。

### 结点间关系/层次
结点的子树的根为该结点的孩子Child，其为Child子树的Parent。同一个parent的child结点称为Sibling。
结点的祖先是从根到该结点所经分支上的所有结点。 反之以某结点为根的子树的任一结点都称为该结点的子孙。
结点的层次Level从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第n层，其子树的根就在第n+1层。parent在同一层的结点称为堂兄弟。 树中结点的最大层次称为树的深度(Depth)或高度。
若将树中结点的各子树看成从左到右是有次序的、不能互换的，则称该树为有序树，否则称为无序树。
森林Forest是m(m》0)课互不相交的树的集合。 对树中的结点而言，其子树的集合即为森林

## 树的存储结构
双亲表示法
孩子表示法 树的度/子树的度
双亲孩子表示法
孩子兄弟表示法 - 把一个复杂的树变成了二叉树

## 二叉树的定义
BinaryTree 是n各结点的有限集合，该集合或为空集，或者由一个跟结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
### 特点
1. 每个结点最多两棵子树。不存在度大于2的结点
2. 左子树和右子树是有顺序的，次序不能颠倒
3.**即使只有一棵子树**，也要区分它是左子树还是右子树。

五种基本形态
1.空二叉树 2.只有一个根结点 3.根结点只有左子树 4.跟结点只有右子树 5.既有左也有右
特殊二叉树
- 斜树 
只有左树的二叉树叫左斜树。当然还有右斜树。
- 满二叉树 
所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。 同样深度的二叉树中，满二叉树结点个数最多。
- 完全二叉树 
对一棵有n个结点的二叉树**按层序编号**，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
满二叉树一定是完全的，但完全并不一定满。
同样结点数的二叉树，完全二叉树深度最小。
最下层的叶结点一定在左部连续。除了一个两例外(满和缺一个右子树)，其他情况下叶子结点一定在最下两层。

## 二叉树的性质
在二叉树的第n层上至多有2的n-1次方个结点。
深度为k的二叉树至多有2的k次方-1个结点
对任何一棵二叉树T，如果其叶结点数为n0，度为2的结点数为n2，则n0=n2+1
具有n个结点的完全二叉树的深度为 log2n+1取整。对其结点按层编号，对任意结点i：i=1，则是根，i>1,则双亲结点是i/2取整；若有，其左孩子为2i，右孩子为2i+1。
## 二叉树的存储结构
完全二叉树用顺序结构就可以表示，这是其优势。但对于其他树实用性不强，所以一般使用链式存储。
### 二叉链表
因为二叉树最多只有两个孩子，为它设计一个数据域和两个指针域是比较自然的data lchild rchild，我们称为二叉链表。如果再增加一个指向parent的指针，则称为三叉链表。
## 遍历二叉树
traversing binary tree是指从根结点出发，按照某种**次序**依次**访问**二叉树中所有结点，使得每个结点被且仅被访问依一次。因为结点间不存在唯一的前驱和后继关系，因此需要面临和线性表不同的选择。
遍历方式有很多，我们首先限制 从左向右，主要分为4种
前序遍历、中序遍历、后续遍历、层序遍历。
前序 root是第一个 后序root是最后一个 中序 root在中间 左边是左树右边是右树
已知 前序/后续 +中序可以确定一棵二叉树

### 前序遍历 PreOrderTraverse
规则：若为空则返回空操作，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。
### 中序遍历 InOrderTraverse
规则：若为空则返回，否则从根结点开始，中序遍历结点的左子树，然后访问根结点，最后中序遍历右子树。
### 后序遍历
规则：若为空则返回空操作，否则从左向右先叶子后结点的方式遍历访问左右子树，最后访问根结点。
### 层序遍历
规则：若为空则返回空操作，否则从树的第一层也就是根结点开始访问，从上而下逐层遍历，在同一层中按从左到右逐个结点访问。

## 二叉树的建立
为了让每个结点确认是否有左右孩子，将每个结点的空指针引出一个虚结点，其值为一定特征值，将这种处理过的二叉树称为原二叉树的扩展二叉树。扩展二叉树可以做到一个遍历序列就能确定其结构 比如前序 AB##D##C##
## 线索二叉树
n个结点的二叉链表，共有2n个指针域；而n个结点的二叉树有n-1条分支； 存在2n-(n-1)=n+1个空指针域。
二叉链表还有一个问题是只知道每个结点其左右孩子的地址(如果有)，而不知道(某种遍历方法下的)前驱是谁后继是谁，需要遍历才知道。
综合这两个问题，利用浪费的空指针域存放(某种遍历方法下的)前驱和后继结点的地址是一种合理的做法。
这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树Threaded Binary Tree。
线索二叉树实际上是将一棵二叉树变成了双向链表。对二叉树以某种次序遍历使其变为线索二叉树的过程称作是**线索化**。
结点结构变为
lchild ltag data rtag rchild.
当ltag为0是 lchild是左孩子，否则是该结点的前驱
当rtag为0是 rchild是右孩子，否则是该结点的后继

和双向链表结构一样，在二叉树线索链表上添加一个头结点，并领其lchild指向二叉树的root，其rchild指向遍历的最后一个结点，这样我们就可以从两头进行遍历。
如果所用的二叉树虚经常遍历或 查找结点时需要某种遍历序列中的前驱和后继，那么非常建议采用线索二叉树。

## 树、森林和二叉树的转换
前面提到树的孩子兄弟法可以将一棵树用二叉链表存储，借助二叉链表可以完成树和二叉树的转换。

### 树转二叉树
1. 加线，在所有的兄弟结点间加一条线
2. 去线，对于树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点间的连线。
3. 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定角度(原本兄弟结点连成线并在一排，旋转的是他们)，使之结构层次分明。第一个孩子是二叉树结点的左孩子，兄弟结点转换过来的孩子是结点的右孩子

### 森林转二叉树
1. 把每棵树都转化为二叉树
2. 第一棵不动，从第二棵开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

### 二叉树转换为树
1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点，及这个右孩子的右孩子...们, 与该结点连接起来；
2. 去线。删除原二叉树中所有结点与其右孩子的连线
3. 调整层次。使之层次分明

### 二叉树转森林
要判断二叉树能够转成树还是森林，通过根结点有没有右孩子判断，有是森林，没有是树。
1. 从根结点开始，如果有右孩子，则把与右孩子的连线删除，再查看分离后的二叉树，重复上述操作，直到所有右孩子的连线都被删除，得到分离的二叉树。
2. 将每棵分离的二叉树转换为树

### 树与森林的遍历
树的遍历分两种
1. 先根遍历，即先访问树的根结点，然后依次先根遍历根的每棵子树。
2.后根遍历，先依次后跟遍历每棵子树，然后再遍历根结点。
森林的遍历分两种
1. 前序遍历 先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样的方法遍历出去第一棵树的剩余树构成的森林。
2. 后续遍历 先访问森林中的第一棵树，后根遍历的方式遍历每个子树，再依次用同样的方法遍历出去第一棵树的剩余树构成的森林。

森林的前序遍历和二叉树的前序遍历结果相同，后序遍历与二叉树的中序遍历结果相同。
以二叉链表作为树的存储结构时，可以完全借助二叉树的遍历方法来实现。
## 哈夫曼树
压缩，把要压缩的文本进行重新编码，以减少不必要的空间。 哈夫曼编码Huffman Coding就是最基本的压缩编码算法。
### 哈夫曼树定义与原理
从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作**路径长度**。
**树的路径长度**就是从树根到每一个结点的路径长度之和。
树结点间的边相关的数叫做权weight。 
结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。
树的带权路径长度为 树中所有**叶子结点**的带权路径长度之和。
带权路径长度WPL最小的二叉树称作哈夫曼树。或最优二叉树。

哈夫曼树构造
1. 根据给定的n个权值构成二叉树的集合F，其中每棵二叉树Ti只有一个带权为Wi的根结点，其左右子树为空；
2.在F中选取权值最小的两棵树作为左右子树构造一棵新的二叉树，新二叉树根结点的权重为左右子树上根结点权值的和；
3.在F重删除这两棵树，同时将新得到的二叉树加入F中；
4.重复2、3，直到F只含一棵树为止，这棵树便是哈夫曼树。

### 哈夫曼编码
使用哈夫曼树来构成哈夫曼编码
设要编码的字符集为 Dn，各个字符在电文中出现的频率为Wn，以Di作为叶子结点，以Wi作为相应叶结点的权值构造一棵哈夫曼树，规定树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。
若要设计长短不等的编码，任一字符的编码都不能是另一个字符的编码的前缀，这种编码称做前缀编码。


