---
title: 大话数据结构读书笔记（1/4）- 绪论/算法/线性表/字符串
date: 2019-05-05 17:01:12
tags:
- 数据结构
- 算法
- 读书笔记
- 字符串
---

《大话数据结构》是一本相对通俗的数据结构和算法基础书籍，大概用了两整天时间读完，整理了如下笔记。
这本书对学习/复习数据结构和算法基础知识很有帮助，尤其是许久不接触算法和数据结构，阅读此书（或者我的笔记）可以迅速让你进入数据结构语境，达到基础入门/查漏补缺/练习刷题的良好状态。读书笔记包含对书本内容的摘录和个人的总结，如有理解错误欢迎指正。如果想要更全面的学习本书的内容，建议直接购买正版书籍进行阅读。

本节是读书笔记的第一部分，包括**绪论**、**数据结构与算法基础**、**线性表**和**字符串** 三方面的内容。

# 绪论
## 定义数据/数据结构

### 数据
数据是描述客观世界的符号 
1. 可以输入到计算机中 
2. 能被计算机程序处理

将现实世界的数据 通过编码手段转换为字符数据类型

**数据元素** 是组成数据的、有一定意义的基本单位。通常作为整体处理。也被称为**记录**。
**数据项** 数据元素由若干数据项构成，是数据不可分割的最小单位。
**数据对象** 性质相同的数据元素的集合，是数据的子集。具有相同数量和类型的数据项。 在实际应用中，处理的元素通常具有相同的性质，因此一般将数据对象简称为数据。

(上述概念的含义： **数据由数据元素构成，数据元素由数据项构成，性质相同的数据元素称为数据对象**，一般实际应用是以**数据对象**为对象，因此它可以简称为**数据**。)

### 结构
结构简单的理解就是**关系**。
是各个组成部分相互搭配和排列的方式，不同数据元素之间不是独立的而是存在一定的关系，这种关系称为结构。
**数据结构** 是相互之间存在一种或多种特定关系的数据元素的集合。

## 数据结构分类
按照视点的不同，分为*逻辑结构*和*物理结构*
### 逻辑结构
逻辑结构是针对具体问题的，在对问题理解的基础上选择一个适合的结构表示元素之间的逻辑关系。
- **集合结构**
类似数学中的集合
- **线性结构**
数据元素之间是一对一的关系
- **树形结构**
数据元素之间存在一对多的层次结构
- **图形结构**
数据元素之间存在多对多的层次结构
### 物理结构
即*存储结构*，指数据的逻辑结构在计算机中的存储形式。(主要针对内存而言，外部存储通常用文件结构来描述) 它分为分两种：
- **顺序存储**
把数据元素存放在地址连续的存储空间里，其数据的逻辑关系与物理关系是一致的。
- **链式存储** 
把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。 存储关系并不反映其逻辑关系。

## 抽象数据类型
**数据类型**：一组性质相同的值的集合及定义在此集合上的一些操作的总称。

数据类型是按照值的不同来划分的
类型用来说明值或者表达式的取值范围和所能进行的操作

C语言中按照取值的不同，数据类型可以分为两类 
*原子类型*： 不可以再分的基本类型 如整型、实型、字符型
*结构类型*： 由若干个类型组合而成，是可以再分解的

**抽象**是指抽取出事物具有的普遍性的本质。
- 抽出特征而忽略非本质的细节。
- 隐藏细节/概括/保留实现目标所必须的信息。

抽象数据类型 abstract data type 一个数学模型及定义在该模型上的一组操作。
抽象的意义在于数据类型的**数学抽象特征**。
抽象数据类型体现了程序设计中问题分解/抽象和信息隐藏的特性。

# 算法
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。

算法的5个特性：
1. 输入 算法有0到多个输入
2. 输出 算法至少有一个或者多个输出
3. **有穷性** 算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤都在可接受的时间内完成。
4. **确定性** 算法的每一个步骤都有确定的含义，不会出现二义性。
5. **可行性** 算法的每一步都必须是可行的，也就是说说每一步都可以通过执行有限次数完成。

## 算法设计的要求
算法不是唯一的，同一问题可以有多种解决的算法，没有标准答案。设计算法遵循的原则如下：
### 正确性
至少具有输入输出和加工处理 无歧义 能正确反映问题的需求 能够得到正确的答案
正确性大概有以下几个层次，要求逐渐提高。
1. 算法没有语法错误
2. 对于合法的输入能够产生满足要求的输出结果
3. 对于非法输入能够得出满足规格说明的结果
4. 对于精心选择的，刁难的测试数据都有满足要求的输出结果
一般来说到达第三层算是一个正确的算法。
因此算法的正确性一般不能用程序来证明，而是数学方法证明的。
### 可读性
算法设计的另一个目的是便于阅读、理解和交流。这也是我们学习数据结构和算法的目的之一，能够更好的与具备知识背景的人进行交流。
### 健壮性
对输入数据不合法的情况做合理的处理，而不是产生异常或者莫名其妙的情况。
### 时间效率高&存储量低
此为算法设计所追求的目标

## 算法效率的度量方法
**事后统计**： 比较实际执行过程/结果，受条件影响较大
**事前分析**： 分析程序运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤

## 函数的渐近增长
给定函数f(n)和g(n)，如果存在一个整数N，使得对于所有n>N，f(n)总是比g(n)大，那么我们认为f(n)的增长渐近快于g(n)。

通过少量数据通常无法准确判断

一般会忽略加法常数，与最高项相乘的常数并不重要

判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，更应该关注主项(最高阶项)的阶数。

## 算法时间复杂度
进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况，并确定T(n)的数量级。
算法的时间复杂度，也就是算法的时间度量记作 T(n)=O(T(n))。它表示随着问题规模n的变大，算法执行时间的增长率和f(n)的增长率相同，称作算法的**渐近时间复杂度**，简称时间复杂度。其中f(n)是问题规模n的某个函数。

这样用O()来体现算法时间复杂度的记法我们称为**大O**记法。
O(1)常数阶 执行时间与问题大小无关
O(n)线性阶 
O(n2)平方阶
O(logn)对数阶

分析算法的复杂度，关键是要**分析循环结构的运行情况**。
大O推导，难点在于对数列的一些运算，考察数学知识和能力
还需要关注 最坏时间复杂度 平均时间复杂度 

#线性表
线性表 list
> 零个和多个数据元素的有限序列。

非空表中每一个元素都有一个确定的位置;除第一个元素外，每个元素有且只有一个直接前驱元素；除最后一个元素外，每个元素有且只有一个直接后继元素。元素之间的**关系是一对一的**。

两种物理类型
- 顺序存储结构 数组
- 链式存储结构 链表

#栈与队列
栈 stack 
> 是限定仅在表尾进行插入和删除操作的线性表。把允许插入和删除的一端称为栈顶top，另一端称为栈底bottom。

LIFO 后进先出结构
- 进栈/插入 push 
- 出栈/删除 pop

顺序存储栈 下标为0的一端作为栈底比较好，因为首元素在这儿，变化比较小
链式存储栈 栈顶放在链表的头部

## 栈的应用 - 后缀表示法
数学表达式求值表示法， 平时我们使用的标准四则运算式为中缀表达式，即所有的运算符号都在两个数字的中间

计算机使用后缀表示法 即逆波兰表示法 Reverse Polish Notation **RPN**
名字叫后缀的原因是因为所有的符号都要在运算数字的后面出现，好处是不需要括号

后缀表达式的计算方法： 
> 从左到右遍历，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈进行运算(计算顺序为由内向外)，结果进栈，一直到最终获得结果。

后缀表达式的转换：
平时我们使用的标准四则运算式为中缀表达式，即所有的运算符号都在两个数字的中间，我们的问题就是中缀向后缀的转换,其规则如下：

> 从左向右遍历中缀表示法的每个数字和符号
如果遇到操作数，直接将其输出
如果遇到操作符，则将其放入到栈中，遇到左括号时也将其放入栈中。
如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，括号只弹出并不输出。
若是其他符号，判断其与栈顶符号的优先级，优先级不高于栈顶符号，则栈顶元依次出栈并输出，并将当前符号进栈，直至得到最终表达式

##队列的定义
queue 只允许在一端进行插入操作，而在另一端进行删除操作的线性表。先进先出。

### 队列顺序存储
引入两个指针，front 队头 rear队尾元素的下一个位置。
front == rear 为空队列。
front在数组中的不断后移容易造成假溢出，所以最好使用循环队列，头尾相接，队列的长度是 (rear-front+queueSize)%queueSize
此时front == rear除了是空外，也可能是满，解决的办法：
1. 引入flag来判断
2. 保留一个元素控件，还剩下一个位置时认为队满。(rear+1)%queueSize == front

### 队列链式存储
队列的链式存储结构其实就是单链表，只不过只能尾进头出而已，简称**链队列**。
为方便将队列头指针指向链表的头结点(此处应该指的是带头链表)，尾指针指向终端结点，队列为空时front 和rear都指向头结点。
入队在链表尾部插入结点 出队将头结点的后继改为它后面的结点。

# 字符串

零个或多个字符组成的有限序列。

串与线性表很类似，不同之处在于串针对的是字符集，其中的元素都是字符。因此其基本操作与线性表有很大的差异，**线性表更关注的是单个元素的操作**，比如查找/插入/删除一个元素；串更多的是查找字串位置/得到指定位置子串/替换子串等操作。
子串的定位操作通常被称做串的**模式匹配**

## KMP 模式匹配算法
主串 siz n， index i
子串 size m， index j
朴素模式匹配，i和j不断的回溯，最坏时间复杂度O((n-m+1)*m)平均？？
这样浪费了很多无谓的的计算，kmp目的是尽量减少不必要的回溯
i 不回溯
j 可能回溯

j的值取决于子串中 当前字符之前的 串的  前后缀的相似程度
子串各个位置j值变化定义一个next数组
根据经验 前后缀n个字符相等 数组对应位置的值为n+1
通过先计算next数组，每次j值回到next数组指定值的位置。

这样能较好的提高效率，尤其是部分匹配较多的情况下 O(n+m)

进一步优化上面的算法
当子串类似aaaab这种类型时，next数组为01234，但对于 后面的a来说，比如比b时不匹配(aaaaxxx)，回到第四个a不匹配，此时按照next数组回到3(没有意义，因为4 3 2 1都相等)也只是再回到2 回到1在到0，说明还有修正的空间(还不如直接回到0)。

引入nextval
改进KMP算法，计算出next的值的同时，如果a位字符与它next值指向的b字符相等，则该a位的nextval就指向b位的nextval值，如果不相等，则该a位 nextval值就是它自己a位的next的值。
```
1 2 3 4 5 6 7 8 9
a b a b a a a b a
0 1 1 2 3 4 2 2 3  next
0 1 0 1 0 4 2 1 0  nextval
```