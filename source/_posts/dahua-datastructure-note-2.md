---
title: 大话数据结构读书笔记（2/4）- 树
date: 2019-05-10 17:01:12
tags:
- 数据结构
- 算法
- 读书笔记
- 树
---

《大话数据结构》是一本相对通俗的数据结构和算法基础书籍，大概用了两整天时间读完，整理了如下笔记。
这本书对学习/复习数据结构和算法基础知识很有帮助，尤其是许久不接触算法和数据结构，阅读此书（或者我的笔记）可以迅速让你进入数据结构语境，达到基础入门/查漏补缺/练习刷题的良好状态。读书笔记包含对书本内容的摘录和个人的总结，如有理解错误欢迎指正。如果想要更全面的学习本书的内容，建议直接购买正版书籍进行阅读。

本节是读书笔记的第二部分，主要为**树**相关的内容。

## 树的定义
Tree 是n个结点的有限集。n = 0时称为空树。在任意非空树中：
1. 有且仅有一个特定的称为根root的结点
2. 当n>1 时，其余结点可以分为 m 个互不相交的有限集 T1、T2、Tn，其中每一个集合本身又是一棵树，并且称为根的子树subTree。

树的定义使用了递归的思想，即 树的定义中包含树。

需要强调的点 
- 根结点是唯一的 
- 子树的个数没有限制，但是它们一定是不相交的，相交就不符合树的定义(成了图)。

### 结点分类
树的结点包含一个数据元素及若干指向其子树的分支。 
结点拥有的子树称为结点的**度Degree**。度为0的结点称为**叶结点Leaf**或者终端结点。度不为0的结点称为非终端结点或者分支结点，除跟结点外分支结点也称为**内部结点**。 **树的度**是树内各结点的度的最大值。

### 结点间关系/层次
结点的子树的根为该结点的孩子Child，其为Child子树的Parent。同一个parent的child结点称为**Sibling兄弟**。
结点的**祖先**是从根到该结点所经分支上的所有结点。 反之以某结点为根的子树的任一结点都称为该结点的子孙。
结点的层次Level从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第n层，其子树的根就在第n+1层。parent在同一层的结点称为堂兄弟。 树中结点的最大层次称为树的**深度(Depth)**或高度。
若将树中结点的各子树看成从左到右是有次序的、不能互换的，则称该树为**有序树**，否则称为无序树。
森林Forest是m(m》0)课互不相交的树的集合。 对树中的结点而言，其子树的集合即为森林

## 树的存储结构
双亲表示法
孩子表示法 树的度/子树的度
双亲孩子表示法
孩子兄弟表示法 - 把一个复杂的树变成二叉树

## 二叉树的定义
BinaryTree 是n个结点的有限集合，该集合或为空集，或者由一个跟结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
### 特点
1. 每个结点最多两棵子树。不存在度大于2的结点
2. 左子树和右子树是有顺序的，次序不能颠倒
3. 即使**只有一棵子树**，也要区分它是左子树还是右子树。

五种基本形态
1.空二叉树 2.只有一个根结点 3.根结点只有左子树 4.跟结点只有右子树 5.既有左也有右

特殊二叉树：
- 斜树 
只有左树的二叉树叫左斜树。当然还有右斜树。
- 满二叉树 
所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上。 同样深度的二叉树中，满二叉树结点个数最多。
- 完全二叉树 
对一棵有n个结点的二叉树**按层序编号**，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
满二叉树一定是完全的，但完全并不一定满。
同样结点数的二叉树，完全二叉树深度最小。
最下层的叶结点一定在左部连续。除了一个两例外(满和缺一个右子树)，其他情况下叶子结点一定在最下两层。

## 二叉树的性质
在二叉树的第n层上至多有2的n-1次方个结点。

深度为k的二叉树至多有2的k次方-1个结点

对任何一棵二叉树T，如果其叶结点数为n0，度为2的结点数为n2，则n0=n2+1

具有n个结点的完全二叉树的深度为 log2n+1取整。对其结点按层编号，对任意结点i：i=1，则是根，i>1,则双亲结点是i/2取整；若有，其左孩子为2i，右孩子为2i+1。
## 二叉树的存储结构
完全二叉树用顺序结构就可以表示，这是其优势。但对于其他树实用性不强，所以一般使用链式存储。
### 二叉链表
因为二叉树最多只有两个孩子，为它设计一个数据域和两个指针域是比较自然的data lchild rchild，我们称为二叉链表。如果再增加一个指向parent的指针，则称为三叉链表。
## 遍历二叉树
traversing binary tree是指从根结点出发，按照某种**次序**依次**访问**二叉树中所有结点，使得每个结点被且仅被访问依一次。因为结点间不存在唯一的前驱和后继关系，因此需要面临和线性表不同的选择。
遍历方式有很多，我们首先限制 从左向右，主要分为4种
前序遍历、中序遍历、后续遍历、层序遍历。
前序 root是第一个 后序root是最后一个 中序 root在中间 左边是左树右边是右树
已知 前序/后续 +中序可以确定一棵二叉树

### 前序遍历 PreOrderTraverse
规则：若为空则返回空操作，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。
### 中序遍历 InOrderTraverse
规则：若为空则返回，否则从根结点开始，中序遍历结点的左子树，然后访问根结点，最后中序遍历右子树。
### 后序遍历
规则：若为空则返回空操作，否则从左向右先叶子后结点的方式遍历访问左右子树，最后访问根结点。
### 层序遍历
规则：若为空则返回空操作，否则从树的第一层也就是根结点开始访问，从上而下逐层遍历，在同一层中按从左到右逐个结点访问。

## 二叉树的建立
为了让每个结点确认是否有左右孩子，将每个结点的空指针引出一个虚结点，其值为一定特征值，将这种处理过的二叉树称为原二叉树的扩展二叉树。扩展二叉树可以做到一个遍历序列就能确定其结构 比如前序 AB##D##C##
## 线索二叉树
n个结点的二叉链表，共有2n个指针域；而n个结点的二叉树有n-1条分支； 存在2n-(n-1)=n+1个空指针域。
二叉链表还有一个问题是只知道每个结点其左右孩子的地址(如果有)，而不知道(某种遍历方法下的)前驱是谁后继是谁，需要遍历才知道。
综合这两个问题，利用浪费的空指针域存放(某种遍历方法下的)前驱和后继结点的地址是一种合理的做法。
这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树Threaded Binary Tree。
线索二叉树实际上是将一棵二叉树变成了双向链表。对二叉树以某种次序遍历使其变为线索二叉树的过程称作是**线索化**。
结点结构变为
lchild ltag data rtag rchild.
当ltag为0是 lchild是左孩子，否则是该结点的前驱
当rtag为0是 rchild是右孩子，否则是该结点的后继

和双向链表结构一样，在二叉树线索链表上添加一个头结点，并领其lchild指向二叉树的root，其rchild指向遍历的最后一个结点，这样我们就可以从两头进行遍历。
如果所用的二叉树虚经常遍历或 查找结点时需要某种遍历序列中的前驱和后继，那么非常建议采用线索二叉树。

## 树、森林和二叉树的转换
前面提到树的孩子兄弟法可以将一棵树用二叉链表存储，借助二叉链表可以完成树和二叉树的转换。

### 树转二叉树
1. 加线，在所有的兄弟结点间加一条线
2. 去线，对于树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点间的连线。
3. 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定角度(原本兄弟结点连成线并在一排，旋转的是他们)，使之结构层次分明。第一个孩子是二叉树结点的左孩子，兄弟结点转换过来的孩子是结点的右孩子

### 森林转二叉树
1. 把每棵树都转化为二叉树
2. 第一棵不动，从第二棵开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

### 二叉树转换为树
1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点，及这个右孩子的右孩子...们, 与该结点连接起来；
2. 去线。删除原二叉树中所有结点与其右孩子的连线
3. 调整层次。使之层次分明

### 二叉树转森林
要判断二叉树能够转成树还是森林，通过根结点有没有右孩子判断，有是森林，没有是树。
1. 从根结点开始，如果有右孩子，则把与右孩子的连线删除，再查看分离后的二叉树，重复上述操作，直到所有右孩子的连线都被删除，得到分离的二叉树。
2. 将每棵分离的二叉树转换为树

### 树与森林的遍历
树的遍历分两种
1. 先根遍历，即先访问树的根结点，然后依次先根遍历根的每棵子树。
2.后根遍历，先依次后跟遍历每棵子树，然后再遍历根结点。
森林的遍历分两种
1. 前序遍历 先访问森林中第一棵树的根结点，然后再依次先跟遍历根的每棵子树，再依次用同样的方法遍历出去第一棵树的剩余树构成的森林。
2. 后续遍历 先访问森林中的第一棵树，后根遍历的方式遍历每个子树，再依次用同样的方法遍历出去第一棵树的剩余树构成的森林。

森林的前序遍历和二叉树的前序遍历结果相同，后序遍历与二叉树的中序遍历结果相同。
以二叉链表作为树的存储结构时，可以完全借助二叉树的遍历方法来实现。
## 哈夫曼树
压缩，把要压缩的文本进行重新编码，以减少不必要的空间。 哈夫曼编码Huffman Coding就是最基本的压缩编码算法。
### 哈夫曼树定义与原理
从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作**路径长度**。
**树的路径长度**就是从树根到每一个结点的路径长度之和。
树结点间的边相关的数叫做权weight。 
结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。
树的带权路径长度为 树中所有**叶子结点**的带权路径长度之和。
带权路径长度WPL最小的二叉树称作哈夫曼树。或最优二叉树。

哈夫曼树构造
1. 根据给定的n个权值构成二叉树的集合F，其中每棵二叉树Ti只有一个带权为Wi的根结点，其左右子树为空；
2. 在F中选取权值最小的两棵树作为左右子树构造一棵新的二叉树，新二叉树根结点的权重为左右子树上根结点权值的和；
3. 在F重删除这两棵树，同时将新得到的二叉树加入F中；
4. 重复2、3，直到F只含一棵树为止，这棵树便是哈夫曼树。

### 哈夫曼编码
使用哈夫曼树来构成哈夫曼编码

设要编码的字符集为Dn，各个字符在电文中出现的频率为Wn，以Di作为叶子结点，以Wi作为相应叶结点的权值构造一棵哈夫曼树，规定树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。
若要设计长短不等的编码，任一字符的编码都不能是另一个字符的编码的前缀，这种编码称做**前缀编码**。


